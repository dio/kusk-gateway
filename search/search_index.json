{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kusk Gateway Kusk Gateway is a self-service API gateway powered by OpenAPI and Envoy ! Kusk Gateway is for you if: You or your team develop REST APIs running in Kubernetes Embrace a contract-first approach to developing your APIs using OpenAPI or Swagger You don't want to spend lots of time configuring hard-to-work-with ingress controllers that require a dedicated Ops Engineer Kusk Gateway is configured through the metadata defined in your OpenAPI or Swagger document. You can apply your API definition like any other Kubernetes resource using our custom-made Kusk Gateway API CustomResourceDefinition (CRDs). Other Custom Resources are used to configure the Envoy Fleet which implements the gateway and specify additional routing configurations. Proceed with our Installation instructions for installing to the generic Kubernetes cluster or use these local installation instructions to evaluate the Kusk Gateway locally with Minikube. Once you have Kusk Gateway installed, feel free to check out the TodoMVC example to deploy backend and frontend with Kusk Gateway.","title":"Welcome"},{"location":"#kusk-gateway","text":"Kusk Gateway is a self-service API gateway powered by OpenAPI and Envoy ! Kusk Gateway is for you if: You or your team develop REST APIs running in Kubernetes Embrace a contract-first approach to developing your APIs using OpenAPI or Swagger You don't want to spend lots of time configuring hard-to-work-with ingress controllers that require a dedicated Ops Engineer Kusk Gateway is configured through the metadata defined in your OpenAPI or Swagger document. You can apply your API definition like any other Kubernetes resource using our custom-made Kusk Gateway API CustomResourceDefinition (CRDs). Other Custom Resources are used to configure the Envoy Fleet which implements the gateway and specify additional routing configurations. Proceed with our Installation instructions for installing to the generic Kubernetes cluster or use these local installation instructions to evaluate the Kusk Gateway locally with Minikube. Once you have Kusk Gateway installed, feel free to check out the TodoMVC example to deploy backend and frontend with Kusk Gateway.","title":"Kusk Gateway"},{"location":"arch/","text":"Architecture","title":"Architecture"},{"location":"arch/#architecture","text":"","title":"Architecture"},{"location":"development/","text":"How to develop Kusk Gateway Kusk Gateway code is managed with the help of Kubebuilder that provides code scaffolding and generation of K8s Custom Resource Definitions files. Internally Kusk Gateway uses the go-control-plane package to configure Envoy with its xDS protocol. We use Minikube as development environment, so the following instructions and the Makefile in the project are tuned to it. Make sure you have Minikube installed before proceeding further. For the MacOS users, the additional configuration step is needed to setup and set as the default for Minikube driver hyperkit . Set up development environment with in-cluster debugging Set up remote debugging for your IDE pointed at localhost:40000 Goland VSCode (see below for a working example) Run make create-env . Once this command finishes you should have the working environment with kusk-gateway-manager running in kusk-system namespace. To attach the IDE to the pod for debugging run make update-debug that will build the debug image inside the Minikube cluster and will update the kusk-gateway-manager deployment. After the deployment kusk-gateway-manager pod will be alive but not running the application since Delve in the container will wait for you to connect to it on port 4000. Run kubectl port-forward deployment/kusk-gateway-manager -n kusk-system 40000:40000 in a new terminal window to create the port-forwarding to Delve port. It is advised to make this as a kind of Task to run from IDE. Run your debug configuration from IDE to connect to port-forwarded localhost port :40000. You can now deploy the httpbin example that creates a backend API service and pushes gateway CRDs to configure Envoy with kubectl apply -f examples/httpbin . Place breakpoints in the code and debug as normal. To test changes to the code, run the following: make generate manifests install docker-build deploy cycle for the usual builds (without the debugging) make update for the usual builds if only the manager code was changed and no CRDs update is needed. make generate manifests install docker-build-debug deploy-debug cycle for debug build. make update-debug for the debug builds if only the manager code was changed and no CRDs update is needed. VSCode launch.json example { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information , visit : https : //go.microsoft.com/fwlink/ ? linkid=830387 \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Connect to server\" , \"type\" : \"go\" , \"request\" : \"attach\" , \"mode\" : \"remote\" , \"remotePath\" : \"${workspaceFolder}\" , \"port\" : 40000 , \"host\" : \"127.0.0.1\" } ] } Run kusk gateway locally Run make create-env Run kubectl apply -f ./config/samples/gateway_v1_envoyfleet.yaml -n kusk-system Run make run This runs the built binary on your machine and creates a tunnel to minikube so envoy and Kusk Gateway running in your IDE can communicate.","title":"For Developers"},{"location":"development/#how-to-develop-kusk-gateway","text":"Kusk Gateway code is managed with the help of Kubebuilder that provides code scaffolding and generation of K8s Custom Resource Definitions files. Internally Kusk Gateway uses the go-control-plane package to configure Envoy with its xDS protocol. We use Minikube as development environment, so the following instructions and the Makefile in the project are tuned to it. Make sure you have Minikube installed before proceeding further. For the MacOS users, the additional configuration step is needed to setup and set as the default for Minikube driver hyperkit .","title":"How to develop Kusk Gateway"},{"location":"development/#set-up-development-environment","text":"","title":"Set up development environment"},{"location":"development/#with-in-cluster-debugging","text":"Set up remote debugging for your IDE pointed at localhost:40000 Goland VSCode (see below for a working example) Run make create-env . Once this command finishes you should have the working environment with kusk-gateway-manager running in kusk-system namespace. To attach the IDE to the pod for debugging run make update-debug that will build the debug image inside the Minikube cluster and will update the kusk-gateway-manager deployment. After the deployment kusk-gateway-manager pod will be alive but not running the application since Delve in the container will wait for you to connect to it on port 4000. Run kubectl port-forward deployment/kusk-gateway-manager -n kusk-system 40000:40000 in a new terminal window to create the port-forwarding to Delve port. It is advised to make this as a kind of Task to run from IDE. Run your debug configuration from IDE to connect to port-forwarded localhost port :40000. You can now deploy the httpbin example that creates a backend API service and pushes gateway CRDs to configure Envoy with kubectl apply -f examples/httpbin . Place breakpoints in the code and debug as normal. To test changes to the code, run the following: make generate manifests install docker-build deploy cycle for the usual builds (without the debugging) make update for the usual builds if only the manager code was changed and no CRDs update is needed. make generate manifests install docker-build-debug deploy-debug cycle for debug build. make update-debug for the debug builds if only the manager code was changed and no CRDs update is needed.","title":"with in-cluster debugging"},{"location":"development/#vscode-launchjson-example","text":"{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information , visit : https : //go.microsoft.com/fwlink/ ? linkid=830387 \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Connect to server\" , \"type\" : \"go\" , \"request\" : \"attach\" , \"mode\" : \"remote\" , \"remotePath\" : \"${workspaceFolder}\" , \"port\" : 40000 , \"host\" : \"127.0.0.1\" } ] }","title":"VSCode launch.json example"},{"location":"development/#run-kusk-gateway-locally","text":"Run make create-env Run kubectl apply -f ./config/samples/gateway_v1_envoyfleet.yaml -n kusk-system Run make run This runs the built binary on your machine and creates a tunnel to minikube so envoy and Kusk Gateway running in your IDE can communicate.","title":"Run kusk gateway locally"},{"location":"extension/","text":"OpenAPI extension Kusk Gateway comes with an OpenAPI extension to accommodate everything within an OpenAPI spec to make that a real source of truth for configuring the gateway. x-kusk extension has the following structure: x-kusk : hosts : - example.com disabled : false validation : request : enabled : true # enable automatic request validation using OpenAPI spec upstream : # upstream and redirect are mutually exclusive host : # host and service are mutually exclusive hostname : example.com port : 80 service : # host and service are mutually exclusive namespace : default service : petstore port : 8000 redirect : # upstream and redirect are mutually exclusive scheme_redirect : https host_redirect : example.org port_redirect : 8081 path_redirect : /index.html # path_redirect and rewrite_regex are mutually exclusive rewrite_regex : # path_redirect and rewrite_regex are mutually exclusive pattern : 'regular_expression' substituion : 'substitution' response_code : 308 strip_query : true path : prefix : /api rewrite : rewrite_regex : pattern : 'regular_expression' substituion : 'substitution' qos : retries : 10 request_timeout : 60 idle_timeout : 30 cors : origins : - \"*\" methods : - POST - GET - OPTIONS headers : - Content-Type credentials : true expose_headers : - X-Custom-Header1 - X-Custom-Header2 max_age : 86200 websocket : true Properties Overview x-kusk extension can be applied at (not exclusively): 1. Top level of an OpenAPI spec: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 x-kusk : hosts : - \"example.org\" disabled : false cors : ... Path level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : x-kusk : disabled : true # disables all /pet endpoints post : ... Method (operation) level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : post : x-kusk : upstream : # routes the POST /pet endpoint to a Kubernetes service service : namespace : default service : petstore port : 8000 ... Property Overriding/inheritance x-kusk extension at the operation level takes precedence, i.e. overrides, what's specified at the path level, including the disabled option. Likewise, the path level settings override what's specified at the global level. If settings aren't specified at a path or operation level, it will inherit from the layer above. (Operation > Path > Global) Available properties disabled This boolean property allows you to disable the corresponding path/operation, allowing you to \"hide\" internal operations from being published to end users. When set to true at the top level all paths will be hidden; you will have to override specific paths/operations with disabled: false to make those operations visible. hosts This string array property configures hosts (i.e. Host HTTP header) list the Gateway will listen traffic for. Wildcard hosts are supported in the suffix or prefix form, exclusively, i.e.: *.example.org example.* cors The cors object sets properties for configuring CORS for your API. Name Description origins list of HTTP origins accepted by the configured operations methods list of HTTP methods accepted by the configured operations headers list of HTTP headers accepted by the configured operations expose_headers list of HTTP headers exposed by the configured operations credentials boolean flag for requiring credentials max_age indicates how long results of a preflight request can be cached qos Options for configuring QoS settings, such as retries and timeouts. Name Description retries maximum number of retries (0 by default) request_timeout total request timeout (in seconds) idle_timeout timeout for idle connections (in seconds) websocket An optional boolean field defines whether to enable handling of \"Upgrade: websocket\" and other related to Websocket HTTP headers in the request to create a Websocket tunnel to the backend. By default false, don't handle Websockets. upstream This setting configures where the traffic goes. service and host are available and are mutually exclusive. The upstream settings is mutually exclusive with redirect setting. service is a reference to a Kubernetes Service inside the cluster, while host can reference any hostname, even outside the cluster. service The service object sets the target service to receive traffic, it contains the following properties: Name Description namespace the namespace containing the upstream Service name the upstream Service's name port the upstream Service's port. Default value is 80 host The host object sets the target host to receive traffic, it contains the following properties: Name Description hostname the hostname to route traffic to port target port to route traffic to redirect Configures where to redirect request to. Redirect and upstream options are mutually exclusive. Name Description scheme_redirect redirect scheme (http / https) host_redirect host to redirect to port_redirect port to redirect to path_redirect path to redirect to rewrite_regex.pattern regular expression (mutually exclusive with path_redirect) rewrite_regex.substitution regular expression substitution strip_query boolean, configures whether to strip the query from the URL (default false) response_code redirect response code (301, 302, 303, 307, 308) path The path object contains the following properties to configure service endpoints paths: Name Description prefix Prefix for the route ( i.e. /your-prefix/here/rest/of/the/route ). Default value is \"/\" rewrite_regex.pattern Regular expression to rewrite the URL rewrite_regex.substitution Regular expression's substitution If a rewrite isn't specified then the upstream service will receive the request as is with any path still appended. Example We have a service foo with a single endpoint /bar . We configure Kusk Gateway to forward traffic to the foo service when it receives traffic on a path with the prefix /foo . If we receive a request at /foo/bar , the request will be forwarded to the foo service. foo will throw a 404 error as it doesn't have a path /foo/bar . Therefore we must rewrite the path from /foo/bar to /bar before sending it onto the foo service. The following config extract will allow us to do this path: # /foo/bar/... -> to upstream: /bar/... rewrite: pattern: \"^/foo\" substitution: \"\" qos The QoS objects contains the following properties to configure quality of service for endpoints: Name Description retries Total number of 5xx retries (default is 0) request_timeout Total request timeout (seconds) idle_timeout Idle connection timeout (seconds) validation The validation objects contains the following properties to configure automatic request validation: Name Description validation.request.enabled boolean flag to enable request validation","title":"Extension (x-kusk) docs"},{"location":"extension/#openapi-extension","text":"Kusk Gateway comes with an OpenAPI extension to accommodate everything within an OpenAPI spec to make that a real source of truth for configuring the gateway. x-kusk extension has the following structure: x-kusk : hosts : - example.com disabled : false validation : request : enabled : true # enable automatic request validation using OpenAPI spec upstream : # upstream and redirect are mutually exclusive host : # host and service are mutually exclusive hostname : example.com port : 80 service : # host and service are mutually exclusive namespace : default service : petstore port : 8000 redirect : # upstream and redirect are mutually exclusive scheme_redirect : https host_redirect : example.org port_redirect : 8081 path_redirect : /index.html # path_redirect and rewrite_regex are mutually exclusive rewrite_regex : # path_redirect and rewrite_regex are mutually exclusive pattern : 'regular_expression' substituion : 'substitution' response_code : 308 strip_query : true path : prefix : /api rewrite : rewrite_regex : pattern : 'regular_expression' substituion : 'substitution' qos : retries : 10 request_timeout : 60 idle_timeout : 30 cors : origins : - \"*\" methods : - POST - GET - OPTIONS headers : - Content-Type credentials : true expose_headers : - X-Custom-Header1 - X-Custom-Header2 max_age : 86200 websocket : true","title":"OpenAPI extension"},{"location":"extension/#properties-overview","text":"x-kusk extension can be applied at (not exclusively): 1. Top level of an OpenAPI spec: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 x-kusk : hosts : - \"example.org\" disabled : false cors : ... Path level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : x-kusk : disabled : true # disables all /pet endpoints post : ... Method (operation) level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : post : x-kusk : upstream : # routes the POST /pet endpoint to a Kubernetes service service : namespace : default service : petstore port : 8000 ...","title":"Properties Overview"},{"location":"extension/#property-overridinginheritance","text":"x-kusk extension at the operation level takes precedence, i.e. overrides, what's specified at the path level, including the disabled option. Likewise, the path level settings override what's specified at the global level. If settings aren't specified at a path or operation level, it will inherit from the layer above. (Operation > Path > Global)","title":"Property Overriding/inheritance"},{"location":"extension/#available-properties","text":"","title":"Available properties"},{"location":"extension/#disabled","text":"This boolean property allows you to disable the corresponding path/operation, allowing you to \"hide\" internal operations from being published to end users. When set to true at the top level all paths will be hidden; you will have to override specific paths/operations with disabled: false to make those operations visible.","title":"disabled"},{"location":"extension/#hosts","text":"This string array property configures hosts (i.e. Host HTTP header) list the Gateway will listen traffic for. Wildcard hosts are supported in the suffix or prefix form, exclusively, i.e.: *.example.org example.*","title":"hosts"},{"location":"extension/#cors","text":"The cors object sets properties for configuring CORS for your API. Name Description origins list of HTTP origins accepted by the configured operations methods list of HTTP methods accepted by the configured operations headers list of HTTP headers accepted by the configured operations expose_headers list of HTTP headers exposed by the configured operations credentials boolean flag for requiring credentials max_age indicates how long results of a preflight request can be cached","title":"cors"},{"location":"extension/#qos","text":"Options for configuring QoS settings, such as retries and timeouts. Name Description retries maximum number of retries (0 by default) request_timeout total request timeout (in seconds) idle_timeout timeout for idle connections (in seconds)","title":"qos"},{"location":"extension/#websocket","text":"An optional boolean field defines whether to enable handling of \"Upgrade: websocket\" and other related to Websocket HTTP headers in the request to create a Websocket tunnel to the backend. By default false, don't handle Websockets.","title":"websocket"},{"location":"extension/#upstream","text":"This setting configures where the traffic goes. service and host are available and are mutually exclusive. The upstream settings is mutually exclusive with redirect setting. service is a reference to a Kubernetes Service inside the cluster, while host can reference any hostname, even outside the cluster.","title":"upstream"},{"location":"extension/#service","text":"The service object sets the target service to receive traffic, it contains the following properties: Name Description namespace the namespace containing the upstream Service name the upstream Service's name port the upstream Service's port. Default value is 80","title":"service"},{"location":"extension/#host","text":"The host object sets the target host to receive traffic, it contains the following properties: Name Description hostname the hostname to route traffic to port target port to route traffic to","title":"host"},{"location":"extension/#redirect","text":"Configures where to redirect request to. Redirect and upstream options are mutually exclusive. Name Description scheme_redirect redirect scheme (http / https) host_redirect host to redirect to port_redirect port to redirect to path_redirect path to redirect to rewrite_regex.pattern regular expression (mutually exclusive with path_redirect) rewrite_regex.substitution regular expression substitution strip_query boolean, configures whether to strip the query from the URL (default false) response_code redirect response code (301, 302, 303, 307, 308)","title":"redirect"},{"location":"extension/#path","text":"The path object contains the following properties to configure service endpoints paths: Name Description prefix Prefix for the route ( i.e. /your-prefix/here/rest/of/the/route ). Default value is \"/\" rewrite_regex.pattern Regular expression to rewrite the URL rewrite_regex.substitution Regular expression's substitution If a rewrite isn't specified then the upstream service will receive the request as is with any path still appended.","title":"path"},{"location":"extension/#example","text":"We have a service foo with a single endpoint /bar . We configure Kusk Gateway to forward traffic to the foo service when it receives traffic on a path with the prefix /foo . If we receive a request at /foo/bar , the request will be forwarded to the foo service. foo will throw a 404 error as it doesn't have a path /foo/bar . Therefore we must rewrite the path from /foo/bar to /bar before sending it onto the foo service. The following config extract will allow us to do this path: # /foo/bar/... -> to upstream: /bar/... rewrite: pattern: \"^/foo\" substitution: \"\"","title":"Example"},{"location":"extension/#qos_1","text":"The QoS objects contains the following properties to configure quality of service for endpoints: Name Description retries Total number of 5xx retries (default is 0) request_timeout Total request timeout (seconds) idle_timeout Idle connection timeout (seconds)","title":"qos"},{"location":"extension/#validation","text":"The validation objects contains the following properties to configure automatic request validation: Name Description validation.request.enabled boolean flag to enable request validation","title":"validation"},{"location":"installation/","text":"Installing Kusk Gateway NOTE This documents describes the installation of the Kusk Gateway and its load balancing component Envoy Fleet to the generic Kubernetes cluster. If you're looking for the quick way to try Kusk Gateway in a locally setup Kubernetes cluster, please see Local Installation with Minikube . Table of contents Prerequsities Cluster requirements Install requirements Installation Uninstallation During the setup we'll deploy Kusk Gateway Custom Resources Definitions, Kusk Gateway Manager and Envoy Fleet with Helm. For the architectural overview of the components please check the Architecture page. Prerequsities Cluster requirements Kubernetes v1.16+ Kubernetes cluster administration rights are required - we install CRDs, service account with ClusterRoles and RoleBindings. If you don't have Jetstack Cert-Manager installed in your cluster, then please follow the official instructions to setup it. We use Cert-Manager for the webhooks configuration. If you have the managed cluster (GCP, EKS, etc) then you can skip to the next section. If you have the baremetal or locally setup cluster, then you should have the controller that manages load balancing setup when a Service with the type LoadBalancer is setup. Otherwise when the Manager creates the Envoy Fleet Service, it will have stuck ExternalIP address in a Pending state forever. MetalLB provides such functionality, so we advise to setup it if you haven't already. Installation requirements Tools needed for the installation: Helm v3 Kubectl Installation We provide 2 Helm charts : kusk-gateway chart provides Custom Resources Definitions as well as the Kusk Gateway Manager (Operator) deployment. You can install only one such chart into a cluster. kusk-gateway-envoyfleet chart provides the EnvoyFleet Custom Resource installation, which is used to configure the gateway with KGW Manager. You can install multiple releases of fleets into a cluster. Container images are hosted on Docker Hub Kusk-Gateway repository . The commands below will install Kusk Gateway and the \"default\" Envoy Fleet (LoadBalancer) in the recommended kusk-system namespace. # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update # Install the Kusk Gateway with CRDs into kusk-system namespace. helm install kusk-gateway kubeshop/kusk-gateway -n kusk-system --create-namespace # We need to wait for the kusk-gateway-manager deployment to finish the setup for the next step. kubectl wait --for = condition = available --timeout = 600s deployment/kusk-gateway-manager -n kusk-system # Install EnvoyFleet into kusk-system namespace. It will be used by the Kusk Gateway # to create Envoy Fleet Deployment and Service with the type LoadBalancer. helm install kusk-gateway-envoyfleet kubeshop/kusk-gateway-envoyfleet -n kusk-system This concludes the installation. This Envoy fleet will be used for all further deployed API and StaticRoutes unless you want to create multiple sites with different IP addresses. In such a case install another release with a different name and/or namespace. Beware that you'll have to specify the fleet to bind to in your API/StaticRoutes after that. To get the External IP address of the Load Balancer run the command below command. Note that it may take a few seconds for the LoadBalancer IP to become available. kubectl get svc -l \"app.kubernetes.io/part-of=kusk-gateway,app.kubernetes.io/component=envoy-svc\" --namespace kusk-system The output should contain the Envoy Fleet Service with the External-IP address field - use this address for your API endpoints querying. You can now deploy your API or Front applications to this cluster and configure access to them with Custom Resources or you can check the ToDoMVC Example for the guidelines on how to do this. In case of the problems please check the Troubleshooting section. Uninstallation The following command will uninstall Kusk Gateway with CRDs and the Envoy Fleet with their namespace. # Delete releases helm delete kusk-gateway-envoyfleet -n kusk-system helm delete kusk-gateway -n kusk-system # Delete namespace too kubectl delete namespace kusk-system","title":"Installation"},{"location":"installation/#installing-kusk-gateway","text":"NOTE This documents describes the installation of the Kusk Gateway and its load balancing component Envoy Fleet to the generic Kubernetes cluster. If you're looking for the quick way to try Kusk Gateway in a locally setup Kubernetes cluster, please see Local Installation with Minikube .","title":"Installing Kusk Gateway"},{"location":"installation/#table-of-contents","text":"Prerequsities Cluster requirements Install requirements Installation Uninstallation During the setup we'll deploy Kusk Gateway Custom Resources Definitions, Kusk Gateway Manager and Envoy Fleet with Helm. For the architectural overview of the components please check the Architecture page.","title":"Table of contents"},{"location":"installation/#prerequsities","text":"","title":"Prerequsities"},{"location":"installation/#cluster-requirements","text":"Kubernetes v1.16+ Kubernetes cluster administration rights are required - we install CRDs, service account with ClusterRoles and RoleBindings. If you don't have Jetstack Cert-Manager installed in your cluster, then please follow the official instructions to setup it. We use Cert-Manager for the webhooks configuration. If you have the managed cluster (GCP, EKS, etc) then you can skip to the next section. If you have the baremetal or locally setup cluster, then you should have the controller that manages load balancing setup when a Service with the type LoadBalancer is setup. Otherwise when the Manager creates the Envoy Fleet Service, it will have stuck ExternalIP address in a Pending state forever. MetalLB provides such functionality, so we advise to setup it if you haven't already.","title":"Cluster requirements"},{"location":"installation/#installation-requirements","text":"Tools needed for the installation: Helm v3 Kubectl","title":"Installation requirements"},{"location":"installation/#installation","text":"We provide 2 Helm charts : kusk-gateway chart provides Custom Resources Definitions as well as the Kusk Gateway Manager (Operator) deployment. You can install only one such chart into a cluster. kusk-gateway-envoyfleet chart provides the EnvoyFleet Custom Resource installation, which is used to configure the gateway with KGW Manager. You can install multiple releases of fleets into a cluster. Container images are hosted on Docker Hub Kusk-Gateway repository . The commands below will install Kusk Gateway and the \"default\" Envoy Fleet (LoadBalancer) in the recommended kusk-system namespace. # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update # Install the Kusk Gateway with CRDs into kusk-system namespace. helm install kusk-gateway kubeshop/kusk-gateway -n kusk-system --create-namespace # We need to wait for the kusk-gateway-manager deployment to finish the setup for the next step. kubectl wait --for = condition = available --timeout = 600s deployment/kusk-gateway-manager -n kusk-system # Install EnvoyFleet into kusk-system namespace. It will be used by the Kusk Gateway # to create Envoy Fleet Deployment and Service with the type LoadBalancer. helm install kusk-gateway-envoyfleet kubeshop/kusk-gateway-envoyfleet -n kusk-system This concludes the installation. This Envoy fleet will be used for all further deployed API and StaticRoutes unless you want to create multiple sites with different IP addresses. In such a case install another release with a different name and/or namespace. Beware that you'll have to specify the fleet to bind to in your API/StaticRoutes after that. To get the External IP address of the Load Balancer run the command below command. Note that it may take a few seconds for the LoadBalancer IP to become available. kubectl get svc -l \"app.kubernetes.io/part-of=kusk-gateway,app.kubernetes.io/component=envoy-svc\" --namespace kusk-system The output should contain the Envoy Fleet Service with the External-IP address field - use this address for your API endpoints querying. You can now deploy your API or Front applications to this cluster and configure access to them with Custom Resources or you can check the ToDoMVC Example for the guidelines on how to do this. In case of the problems please check the Troubleshooting section.","title":"Installation"},{"location":"installation/#uninstallation","text":"The following command will uninstall Kusk Gateway with CRDs and the Envoy Fleet with their namespace. # Delete releases helm delete kusk-gateway-envoyfleet -n kusk-system helm delete kusk-gateway -n kusk-system # Delete namespace too kubectl delete namespace kusk-system","title":"Uninstallation"},{"location":"local-installation/","text":"Installing Kusk Gateway to the Local Minikube cluster NOTE This is the quick instruction on how to setup the Kusk Gateway and try it out with Minikube on the local machine. If you're looking for the generic Kubernetes installation instructions, please see Installation . Table of contents Prerequsities Installation Uninstallation During the installation we'll create the Minikube Kubernetes cluster, deploy the Kusk Gateway with its Custom Resources Definitions and Envoy Fleet. After that you'll be able to go through our ToDoMVC example that configures access to API with OpenAPI file and Kusk Gateway. For the architectural overview of these components please check the Architecture page. Installation requirements Tools needed for the installation: Minikube . Make sure you had its Installation step finished, you can skip other steps as not needed. For the MacOS users, the additional configuration step is needed to setup and set as the default for Minikube driver hyperkit . Helm v3 Kubectl Installation Start the local Minikube cluster This will switch the default kubectl context to this new cluster kgw. # Start cluster. minikube start --profile kgw Next we setup all components and Kusk Gateway Commands below will configure necessary cluster component such as Jetstack Cert-Manager for webhooks configuration and MetalLB that is needed to finish the configuration of the Service with the type LoadBalancer . After that we'll install the Kusk Gateway and the \"default\" Envoy Fleet (LoadBalancer) in the recommended kusk-system namespace with Helm. We provide 2 Helm charts : kusk-gateway chart provides Custom Resources Definitions as well as the Kusk Gateway Manager (Operator) deployment. kusk-gateway-envoyfleet chart provides the EnvoyFleet Custom Resource installation, which is used to configure the gateway with KGW Manager. Container images are hosted on Docker Hub Kusk-Gateway repository . You can select and copy all of these commands as one block and paste it into the terminal for the speed of installation. # determine load balancer ingress range cidr_base_addr = $( minikube ip --profile kgw ) ingress_first_addr = $( echo \" $cidr_base_addr \" | awk -F '.' '{print $1,$2,$3,2}' OFS = '.' ) ingress_last_addr = $( echo \" $cidr_base_addr \" | awk -F '.' '{print $1,$2,$3,255}' OFS = '.' ) ingress_range = $ingress_first_addr - $ingress_last_addr # deploy metallb kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.11.0/manifests/namespace.yaml kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.11.0/manifests/metallb.yaml # configure metallb ingress address range cat <<EOF | kubectl apply -f - apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - $ingress_range EOF # Install Jetstack Cert Manager and wait for it to be ready kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.6.0/cert-manager.yaml && \\ kubectl wait --for = condition = available --timeout = 600s deployment/cert-manager-webhook -n cert-manager # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts && helm repo update # Install the Kusk Gateway with CRDs into kusk-system namespace. # We need to wait for the kusk-gateway-manager deployment to finish the setup for the next step. helm install kusk-gateway kubeshop/kusk-gateway -n kusk-system --create-namespace && \\ kubectl wait --for = condition = available --timeout = 600s deployment/kusk-gateway-manager -n kusk-system # Install the \"default\" EnvoyFleet Custom Resource, which will be used by the Kusk Gateway # to create Envoy Fleet Deployment and Service with the type LoadBalancer helm install kusk-gateway-envoyfleet kubeshop/kusk-gateway-envoyfleet -n kusk-system This concludes the installation. It may take a few seconds for the LoadBalancer IP to become available. Run this to find out the External IP address of EnvoyFleet Load balancer. kubectl get svc -l \"app=kusk-gateway,component=envoy-svc\" --namespace default The output should contain the Service kusk-envoy-svc-default with the External-IP address field - use this address for your API endpoints querying. You can now deploy your API or Front applications to this cluster and configure access to them with Custom Resources or you can check the ToDoMVC Example for the guidelines on how to do this. In case of the problems please check the Troubleshooting section. Uninstallation The following command will delete the Minikube cluster. minikube delete --profile kgw","title":"Installing Kusk Gateway to the Local Minikube cluster"},{"location":"local-installation/#installing-kusk-gateway-to-the-local-minikube-cluster","text":"NOTE This is the quick instruction on how to setup the Kusk Gateway and try it out with Minikube on the local machine. If you're looking for the generic Kubernetes installation instructions, please see Installation .","title":"Installing Kusk Gateway to the Local Minikube cluster"},{"location":"local-installation/#table-of-contents","text":"Prerequsities Installation Uninstallation During the installation we'll create the Minikube Kubernetes cluster, deploy the Kusk Gateway with its Custom Resources Definitions and Envoy Fleet. After that you'll be able to go through our ToDoMVC example that configures access to API with OpenAPI file and Kusk Gateway. For the architectural overview of these components please check the Architecture page.","title":"Table of contents"},{"location":"local-installation/#installation-requirements","text":"Tools needed for the installation: Minikube . Make sure you had its Installation step finished, you can skip other steps as not needed. For the MacOS users, the additional configuration step is needed to setup and set as the default for Minikube driver hyperkit . Helm v3 Kubectl","title":"Installation requirements"},{"location":"local-installation/#installation","text":"Start the local Minikube cluster This will switch the default kubectl context to this new cluster kgw. # Start cluster. minikube start --profile kgw Next we setup all components and Kusk Gateway Commands below will configure necessary cluster component such as Jetstack Cert-Manager for webhooks configuration and MetalLB that is needed to finish the configuration of the Service with the type LoadBalancer . After that we'll install the Kusk Gateway and the \"default\" Envoy Fleet (LoadBalancer) in the recommended kusk-system namespace with Helm. We provide 2 Helm charts : kusk-gateway chart provides Custom Resources Definitions as well as the Kusk Gateway Manager (Operator) deployment. kusk-gateway-envoyfleet chart provides the EnvoyFleet Custom Resource installation, which is used to configure the gateway with KGW Manager. Container images are hosted on Docker Hub Kusk-Gateway repository . You can select and copy all of these commands as one block and paste it into the terminal for the speed of installation. # determine load balancer ingress range cidr_base_addr = $( minikube ip --profile kgw ) ingress_first_addr = $( echo \" $cidr_base_addr \" | awk -F '.' '{print $1,$2,$3,2}' OFS = '.' ) ingress_last_addr = $( echo \" $cidr_base_addr \" | awk -F '.' '{print $1,$2,$3,255}' OFS = '.' ) ingress_range = $ingress_first_addr - $ingress_last_addr # deploy metallb kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.11.0/manifests/namespace.yaml kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.11.0/manifests/metallb.yaml # configure metallb ingress address range cat <<EOF | kubectl apply -f - apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - $ingress_range EOF # Install Jetstack Cert Manager and wait for it to be ready kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.6.0/cert-manager.yaml && \\ kubectl wait --for = condition = available --timeout = 600s deployment/cert-manager-webhook -n cert-manager # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts && helm repo update # Install the Kusk Gateway with CRDs into kusk-system namespace. # We need to wait for the kusk-gateway-manager deployment to finish the setup for the next step. helm install kusk-gateway kubeshop/kusk-gateway -n kusk-system --create-namespace && \\ kubectl wait --for = condition = available --timeout = 600s deployment/kusk-gateway-manager -n kusk-system # Install the \"default\" EnvoyFleet Custom Resource, which will be used by the Kusk Gateway # to create Envoy Fleet Deployment and Service with the type LoadBalancer helm install kusk-gateway-envoyfleet kubeshop/kusk-gateway-envoyfleet -n kusk-system This concludes the installation. It may take a few seconds for the LoadBalancer IP to become available. Run this to find out the External IP address of EnvoyFleet Load balancer. kubectl get svc -l \"app=kusk-gateway,component=envoy-svc\" --namespace default The output should contain the Service kusk-envoy-svc-default with the External-IP address field - use this address for your API endpoints querying. You can now deploy your API or Front applications to this cluster and configure access to them with Custom Resources or you can check the ToDoMVC Example for the guidelines on how to do this. In case of the problems please check the Troubleshooting section.","title":"Installation"},{"location":"local-installation/#uninstallation","text":"The following command will delete the Minikube cluster. minikube delete --profile kgw","title":"Uninstallation"},{"location":"observability/","text":"Observability Envoy's Admin interface Envoy's admin interface is opened on 19000 port and could be used for the troubleshooting, configuration dumps, changing logs levels and other administrative tasks. Refer to the Troubleshooting on the usage. Metrics Envoy exposes Stats service on admin interface. Currently we don't configure any stats sinks to publish the metrics, but Prometheus can discover Envoy pods and query them for the metrics if pods have the following annotations: annotations : prometheus.io/scrape : 'true' prometheus.io/port : '19000' prometheus.io/path : /stats/prometheus This can be configured with EnvoyFleet Custom resource spec.annotations field. The list of exported HTTP metrics is described in HTTP connection manager Statistics , see also Listener metrics .","title":"Observability"},{"location":"observability/#observability","text":"","title":"Observability"},{"location":"observability/#envoys-admin-interface","text":"Envoy's admin interface is opened on 19000 port and could be used for the troubleshooting, configuration dumps, changing logs levels and other administrative tasks. Refer to the Troubleshooting on the usage.","title":"Envoy's Admin interface"},{"location":"observability/#metrics","text":"Envoy exposes Stats service on admin interface. Currently we don't configure any stats sinks to publish the metrics, but Prometheus can discover Envoy pods and query them for the metrics if pods have the following annotations: annotations : prometheus.io/scrape : 'true' prometheus.io/port : '19000' prometheus.io/path : /stats/prometheus This can be configured with EnvoyFleet Custom resource spec.annotations field. The list of exported HTTP metrics is described in HTTP connection manager Statistics , see also Listener metrics .","title":"Metrics"},{"location":"todomvc/","text":"TodoMVC step by step example This example will show you how to deploy a famous TodoMVC website using Kusk Gateway. We chose the TodoBackend implementation for an example. The website consists of a Go-powered backend and a NodeJS SPA frontend that talks to the backend. The backend application comes with an OpenAPI specification , which we will use to configure the Kusk Gateway. In order to let the frontend communicate with the backend, modern browsers require CORS to be properly configured. Luckily, Kusk Gateway Manager allows you to do that right in your OpenAPI specification file using the x-kusk extension . Prerequisites Kusk Gateway Manager installed into the cluster Envoy LoadBalancer IP is reachable from your browser - we will refer to it as EXTERNAL_IP Deploy services First, deploy the backend and frontend services: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/backend.yaml kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/frontend.yaml Expose the backend API via Kusk Gateway: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-backend-api.yaml Expose the frontend via Kusk Gateway: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-frontend-route.yaml Test access We assume that you have followed the installation instructions and have determined the external IP of the EnvoyFleet Service: export EXTERNAL_IP = 192 .168.64.2 # this IP is example, yours will be different Now, open the frontend in your browser: ( http://192.168.64.2:8080/ ) and put http://192.168.64.2:8080/todos as your backend endpoint: You should now see the TodoMVC app running against your backend, with Kusk Gateway delivering traffic to it via the EnvoyFleet: How it's done - backend Inside the x-kusk extension upstream is specified so that Kusk knows where to route traffic to: x-kusk : upstream : service : namespace : default name : todo-backend port : 3000 Then, CORS is configured: x-kusk : upstream : service : namespace : default name : todo-backend port : 3000 cors : origins : - '*' methods : - POST - PATCH - DELETE - PUT - GET - OPTIONS headers : - Content-Type credentials : true max_age : 86200 Now, in order to apply it to our cluster, you need to envelope it in a API CRD. You can do it either manually: apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : todo spec : spec : | # your spec goes here - be careful about the indentation Or by using kgw CLI tool: kgw api generate -i https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/spec/todospec.yaml --name todo > kusk-backend-api.yaml Apply it to the cluster: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-backend-api.yaml or pipe directly from kgw CLI - you can even do it in your CI/CD: kgw api generate -i https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/todospec.yaml --name todo | kubectl apply -f - How it's done - frontend In order to configure access to services that do not have an OpenAPI specification, Kusk Gateway allows you to use a StaticRoute CRD. Example kusk-frontend-route.yaml file : apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : todo-frontend spec : # should work with localhost, example.org hosts : [ \"localhost\" , \"*\" ] paths : # Root goes to frontend service / : get : route : upstream : service : namespace : default name : todo-frontend port : 3000 And apply it to the cluster: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-frontend-route.yaml","title":"TodoMVC example"},{"location":"todomvc/#todomvc-step-by-step-example","text":"This example will show you how to deploy a famous TodoMVC website using Kusk Gateway. We chose the TodoBackend implementation for an example. The website consists of a Go-powered backend and a NodeJS SPA frontend that talks to the backend. The backend application comes with an OpenAPI specification , which we will use to configure the Kusk Gateway. In order to let the frontend communicate with the backend, modern browsers require CORS to be properly configured. Luckily, Kusk Gateway Manager allows you to do that right in your OpenAPI specification file using the x-kusk extension .","title":"TodoMVC step by step example"},{"location":"todomvc/#prerequisites","text":"Kusk Gateway Manager installed into the cluster Envoy LoadBalancer IP is reachable from your browser - we will refer to it as EXTERNAL_IP","title":"Prerequisites"},{"location":"todomvc/#deploy-services","text":"First, deploy the backend and frontend services: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/backend.yaml kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/frontend.yaml Expose the backend API via Kusk Gateway: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-backend-api.yaml Expose the frontend via Kusk Gateway: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-frontend-route.yaml Test access We assume that you have followed the installation instructions and have determined the external IP of the EnvoyFleet Service: export EXTERNAL_IP = 192 .168.64.2 # this IP is example, yours will be different Now, open the frontend in your browser: ( http://192.168.64.2:8080/ ) and put http://192.168.64.2:8080/todos as your backend endpoint: You should now see the TodoMVC app running against your backend, with Kusk Gateway delivering traffic to it via the EnvoyFleet:","title":"Deploy services"},{"location":"todomvc/#how-its-done-backend","text":"Inside the x-kusk extension upstream is specified so that Kusk knows where to route traffic to: x-kusk : upstream : service : namespace : default name : todo-backend port : 3000 Then, CORS is configured: x-kusk : upstream : service : namespace : default name : todo-backend port : 3000 cors : origins : - '*' methods : - POST - PATCH - DELETE - PUT - GET - OPTIONS headers : - Content-Type credentials : true max_age : 86200 Now, in order to apply it to our cluster, you need to envelope it in a API CRD. You can do it either manually: apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : todo spec : spec : | # your spec goes here - be careful about the indentation Or by using kgw CLI tool: kgw api generate -i https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/spec/todospec.yaml --name todo > kusk-backend-api.yaml Apply it to the cluster: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-backend-api.yaml or pipe directly from kgw CLI - you can even do it in your CI/CD: kgw api generate -i https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/todospec.yaml --name todo | kubectl apply -f -","title":"How it's done - backend"},{"location":"todomvc/#how-its-done-frontend","text":"In order to configure access to services that do not have an OpenAPI specification, Kusk Gateway allows you to use a StaticRoute CRD. Example kusk-frontend-route.yaml file : apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : todo-frontend spec : # should work with localhost, example.org hosts : [ \"localhost\" , \"*\" ] paths : # Root goes to frontend service / : get : route : upstream : service : namespace : default name : todo-frontend port : 3000 And apply it to the cluster: kubectl apply -f https://raw.githubusercontent.com/kubeshop/kusk-gateway/main/examples/todomvc/kusk-frontend-route.yaml","title":"How it's done - frontend"},{"location":"troubleshooting/","text":"Troubleshooting To see what routes are set up on the gateway Get the name of your envoy fleet deployment \u276f kubectl get deployment -n kusk-system NAME READY UP-TO-DATE AVAILABLE AGE kusk-gateway-manager 1/1 1 1 15m kusk-gateway-envoy-default 1/1 1 1 2m33s For this example, it's kusk-envoy-default . Be sure to query the correct namespace for your installation. Port forward to the envoy deployment on port 19000 The admin console is configured to listen on port 19000 so we will port forward to it \u276f kubectl port-forward deployment/kusk-envoy-default -n kusk-system 19000 Forwarding from 127.0.0.1:19000 -> 19000 Forwarding from [::1]:19000 -> 19000 Handling connection for 19000 Hit localhost:19000/config_dump in your browser Alternatively, use curl and jq to query routes curl http://localhost:19000/config_dump | jq '.configs[] | select(.[\"@type\"] == \"type.googleapis.com/envoy.admin.v3.RoutesConfigDump\") | .dynamic_route_configs[].route_config.virtual_hosts[].routes[]' If the command hangs at all, cancel it and run it again Webhooks timeouts during the deployment You may meet the error during the resources deployment with kubectl like: Error from server ( InternalError ) : error when creating \"examples/todomvc/kusk-backend-api.yaml\" : Internal error occurred: failed calling webhook \"mapi.kb.io\" : failed to call webhook: Post \"https://kusk-gateway-webhooks-service.kusk-system.svc:443/mutate-gateway-kusk-io-v1alpha1-api?timeout=10s\" : context deadline exceeded This means that K8s masters control plane can't call the webhooks service residing on Kusk Gateway Manager on TCP port 9443. This problem is not specific to Kusk Gateway Manager itself and is related to the configuration of you cluster and the firewall rules. In your firewall settings you will need to add port 9443 to the rule containing the list of ports, allowed to be accessed by K8s masters control plane.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#to-see-what-routes-are-set-up-on-the-gateway","text":"","title":"To see what routes are set up on the gateway"},{"location":"troubleshooting/#get-the-name-of-your-envoy-fleet-deployment","text":"\u276f kubectl get deployment -n kusk-system NAME READY UP-TO-DATE AVAILABLE AGE kusk-gateway-manager 1/1 1 1 15m kusk-gateway-envoy-default 1/1 1 1 2m33s For this example, it's kusk-envoy-default . Be sure to query the correct namespace for your installation.","title":"Get the name of your envoy fleet deployment"},{"location":"troubleshooting/#port-forward-to-the-envoy-deployment-on-port-19000","text":"The admin console is configured to listen on port 19000 so we will port forward to it \u276f kubectl port-forward deployment/kusk-envoy-default -n kusk-system 19000 Forwarding from 127.0.0.1:19000 -> 19000 Forwarding from [::1]:19000 -> 19000 Handling connection for 19000","title":"Port forward to the envoy deployment on port 19000"},{"location":"troubleshooting/#hit-localhost19000config_dump-in-your-browser","text":"","title":"Hit localhost:19000/config_dump in your browser"},{"location":"troubleshooting/#alternatively-use-curl-and-jq-to-query-routes","text":"curl http://localhost:19000/config_dump | jq '.configs[] | select(.[\"@type\"] == \"type.googleapis.com/envoy.admin.v3.RoutesConfigDump\") | .dynamic_route_configs[].route_config.virtual_hosts[].routes[]' If the command hangs at all, cancel it and run it again","title":"Alternatively, use curl and jq to query routes"},{"location":"troubleshooting/#webhooks-timeouts-during-the-deployment","text":"You may meet the error during the resources deployment with kubectl like: Error from server ( InternalError ) : error when creating \"examples/todomvc/kusk-backend-api.yaml\" : Internal error occurred: failed calling webhook \"mapi.kb.io\" : failed to call webhook: Post \"https://kusk-gateway-webhooks-service.kusk-system.svc:443/mutate-gateway-kusk-io-v1alpha1-api?timeout=10s\" : context deadline exceeded This means that K8s masters control plane can't call the webhooks service residing on Kusk Gateway Manager on TCP port 9443. This problem is not specific to Kusk Gateway Manager itself and is related to the configuration of you cluster and the firewall rules. In your firewall settings you will need to add port 9443 to the rule containing the list of ports, allowed to be accessed by K8s masters control plane.","title":"Webhooks timeouts during the deployment"},{"location":"customresources/","text":"Custom Resources Custom Resources is the Kubernetes concept to extend K8s API with third party APIs. They're deployed as YAML manifests files and are picked up by the Kusk Gateway Manager to configure Envoy settings and routing. Currently we support the following Custom Resources: EnvoyFleet - configuration for setting up Envoy Fleet. API - OpenAPI based routing configuration. StaticRoute - Manually created routing configuration.","title":"Custom Resources"},{"location":"customresources/#custom-resources","text":"Custom Resources is the Kubernetes concept to extend K8s API with third party APIs. They're deployed as YAML manifests files and are picked up by the Kusk Gateway Manager to configure Envoy settings and routing. Currently we support the following Custom Resources: EnvoyFleet - configuration for setting up Envoy Fleet. API - OpenAPI based routing configuration. StaticRoute - Manually created routing configuration.","title":"Custom Resources"},{"location":"customresources/api/","text":"API This resource uses OpenAPI file with x-kusk annotations as the source of truth to configure routing. Refer to extention for the further information on how to add routing information to OpenAPI file. The required field of API resource is spec. spec where x-kusk -enhanced OpenAPI file is supplied as an embedded string. You can generate it (and integrate into your CI) using kgw CLI tool. The optional spec. fleet field specifies to what Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies to. fleet. name and fleet. namespace reference the deployed EnvoyFleet Custom Resource name and namespace. You can deploy you API configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, the autodetection will be performed to find the single deployed in the Kubernetes cluster fleet which is thus considered as the default fleet. The deployed API custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, the spec. fleet is required to specify in the manifest. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any update with these resource. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) would result in error. Alpha Limitations : currently resource status field is not updated by manager when the configuration process finishes. Example apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : api-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster. fleet : name : default namespace : default # OpenAPI file with x-kusk annotation here spec : | openapi: 3.0.2 servers: - url: /api/v3 info: description: Some description version: 1.0.0 title: the best API in the world # top level x-kusk extension to configure routes x-kusk: disabled: false hosts: [ \"*\" ] cors: origins: - \"*\" methods: - POST - GET - OPTIONS headers: - Content-Type credentials: true expose_headers: - X-Custom-Header1 max_age: 86200 upstream: service: name: oldapi namespace: default port: 80 path: prefix: /api # Strips prefix when forwarding to upstream rewrite: pattern: \"^/api\" substitution: \"\" paths: /pet: x-kusk: disabled: true post: x-kusk: disabled: false upstream: host: hostname: newapi.default.svc.cluster.local port: 8080 --- skipped --- put: summary: Update pet description: Update an existing pet by Id operationId: updatePet --- skipped ---","title":"API"},{"location":"customresources/api/#api","text":"This resource uses OpenAPI file with x-kusk annotations as the source of truth to configure routing. Refer to extention for the further information on how to add routing information to OpenAPI file. The required field of API resource is spec. spec where x-kusk -enhanced OpenAPI file is supplied as an embedded string. You can generate it (and integrate into your CI) using kgw CLI tool. The optional spec. fleet field specifies to what Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies to. fleet. name and fleet. namespace reference the deployed EnvoyFleet Custom Resource name and namespace. You can deploy you API configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, the autodetection will be performed to find the single deployed in the Kubernetes cluster fleet which is thus considered as the default fleet. The deployed API custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, the spec. fleet is required to specify in the manifest. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any update with these resource. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) would result in error. Alpha Limitations : currently resource status field is not updated by manager when the configuration process finishes. Example apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : api-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster. fleet : name : default namespace : default # OpenAPI file with x-kusk annotation here spec : | openapi: 3.0.2 servers: - url: /api/v3 info: description: Some description version: 1.0.0 title: the best API in the world # top level x-kusk extension to configure routes x-kusk: disabled: false hosts: [ \"*\" ] cors: origins: - \"*\" methods: - POST - GET - OPTIONS headers: - Content-Type credentials: true expose_headers: - X-Custom-Header1 max_age: 86200 upstream: service: name: oldapi namespace: default port: 80 path: prefix: /api # Strips prefix when forwarding to upstream rewrite: pattern: \"^/api\" substitution: \"\" paths: /pet: x-kusk: disabled: true post: x-kusk: disabled: false upstream: host: hostname: newapi.default.svc.cluster.local port: 8080 --- skipped --- put: summary: Update pet description: Update an existing pet by Id operationId: updatePet --- skipped ---","title":"API"},{"location":"customresources/envoyfleet/","text":"Envoy Fleet This resource defines the EnvoyFleet, which is the implementation of the gateway in Kubernetes based on Envoy Proxy. Once the resource manifest is deployed to Kubernetes, it is used by Kusk Gateway Manager to setup K8s Envoy Proxy Deployment , ConfigMap and Service . The ConfigMap config bootstraps Envoy Proxy to connect to the XDS service of the KGW Manager to retrieve the configuration. In its initial state there is a minimal configuration, you have to deploy API or StaticRoute resource to setup the routing. If the Custom Resource is uninstalled, the Manager deletes the created K8s resources. You can deploy multiple Envoy Fleets and thus have multiple Gateways available. Once the fleet is deployed, it status field shows the success of the process (Deployed, Failed), so it can be shown with kubectl describe envoyfleet command. Alpha Limitations : currently it shows only the success of K8s resources deployment, it doesn't show if the Envoy Proxy pods are alive and if the Service has the External IP Address allocated. Currently supported parameters: metadata. name and metadata. namespace are used as the EnvoyFleet ID. The Manager will supply the configuration for this specific ID - Envoy will connect to the KGW Manager with it. API/StaticRoute can be deployed to this fleet using their fleet name field. spec. image is the Envoy Proxy container image tag, usually envoyproxy/envoy-alpine. spec. service defines the configuration of the K8s Service that exposes Envoy Proxy deployment. It has similar to the K8s Service configuration but with the limited set of fields. spec.service. type - select the Service type (NodePort, ClusterIP, LoadBalancer). spec.service. ports - expose TCP ports (80, 443 or any other), routed to the ports names that Deployment exposes (http, https) - ports that Envoy Proxy listener binds to. spec.service. annotations - add annotations to the Service that will control load balancer configuration in the specific cloud providers implementations (e.g. to setup the internal Google Cloud Platform load balancer in Google Cloud Engine we annotate Service with the related annotation). spec.service. loadBalancerIP can be used to specify the pre-allocated Load Balancer IP address, so it won't be deleted in case the Service is deleted. spec.service. externalTrafficPolicy optional parameter denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. \"Local\" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. \"Cluster\" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. For the preservation of the real client ip in access logs chose \"Local\" spec. size optional parameter is the number of Envoy Proxy pods in the K8s deployment, defaults to 1 if not specified. spec. resources optional parameter configures Envoy Proxy container CPU/Memory requests and limits - read Resource Management for Pods and Containers for the details. By default we don't specify any requests or limits. spec. annotations optional parameter adds additional annotations to the Envoy Proxy pods, e.g. for the Prometheus scraping. spec. nodeSelector , spec. tolerations and spec. affinity optional parameters provide the Envoy Proxy deployment settings for the K8s Pod scheduler. Read Assigning Pods to Nodes to understand how can you bind Envoy pods to some type of nodes (e.g. non-preemtible node type pool) and how to ensure that Envoy pods are placed onto the different nodes for the High Availability. See the YAML example below too. The structure of these fields are the same as for K8s Deployment. All these options could be used simultaneously influencing each other. spec. accesslog optional parameter defines Envoy Proxy stdout HTTP requests logging. Each Envoy pod can stream access log to stdout. If not specified - no streaming. If specified, you must chose the format and optionally - text or json template to tune the output. spec.accesslog. format required parameter specifies the format of the output json (structured) or text . Note that json format doesn't preserve fields order. spec.accesslog. text_template | json_template optional parameters could be used to specify what exactly available Envoy request data to log. See Envoy's Access Logging for the details. If not specified any - use Kusk Gateway provided defaults. spec. tls optional parameter defines TLS settings for the EnvoyFleet. If not specified, the EnvoyFleet will accept only HTTP traffic. spec.tls. cipherSuites An optional field, if specified, the TLS listener will only support the specified cipher list when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3). If not specified, a default list will be used. Defaults are different for server (downstream) and client (upstream) TLS configurations. For more information see: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto spec.tls. tlsMinimumProtocolVersion An optional field specifying the minimum TLS protocol version. By default, it\u2019s TLSv1_2 for clients and TLSv1_0 for servers. spec.tls. tlsMaximumProtocolVersion An optional field specifying the maximum TLS protocol version. By default, it\u2019s TLSv1_2 for clients and TLSv1_3 for servers. spec.tls. tlsSecrets Secret name and namespace combinations for locating TLS secrets containing TLS certificates. You can specify more than one. Kusk Gateway Manager pulls the certificates from the secrets, extracts the matching hostnames from SubjectAlternativeNames (SAN) certificate field and configures Envoy to use that certificate for those hostnames. spec.tls.tlsSecrets. secretRef is the name of the Kubernetes secret containing the TLS certificate. spec.tls.tlsSecrets. namespace is the namespace where that Kubernetes secret resides. apiVersion : gateway.kusk.io/v1alpha1 kind : EnvoyFleet metadata : name : default namespace : default spec : image : \"envoyproxy/envoy-alpine:v1.20.0\" service : # NodePort, ClusterIP, LoadBalancer type : LoadBalancer # Specify annotations to modify service behaviour, e.g. for GCP to create internal load balancer: # annotations: # networking.gke.io/load-balancer-type: \"Internal\" # Specify preallocated static load balancer IP address if present #loadBalancerIP: 10.10.10.10 ports : - name : http port : 80 targetPort : http - name : https port : 443 targetPort : http # externalTrafficPolicy: Cluster|Local resources : # limits: # cpu: 1 # memory: 100M requests : cpu : 10m memory : 100M # Put any additional annotations to the Enovy pod. # Here we add the annotations for the Prometheus service discovery to scrape Envoy pods for the Prometheus metrics. # annotations: # prometheus.io/scrape: 'true' # prometheus.io/port: '19000' # prometheus.io/path: /stats/prometheus ##### Scheduling directives # Read https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/ for the details. # Optional - schedule Envoy pods to the node with the label \"disktype=ssd\". # nodeSelector: # disktype: \"ssd\" # Optional - allow to be scheduled on the \"tainted\" node. Taint with \"kubectl taint nodes node1 key1=value1:NoSchedule\". # Taints will repel the pods from the node unless the pods have the specific toleration. # The line below will allow this specific Envoy pod to be scheduled there (but scheduler decideds where to put it anyway). # tolerations: # - key: \"key1\" # operator: \"Exists\" # effect: \"NoSchedule\" # Optional - provide pods affinity and anti-affinity settings. # This is more flexible than nodeSelector scheme but they can be specified together. # For the scalability and fault tolerance we prefer to put all Envoy pods onto different nodes - in a case one node fails we survive on others. # The block below will search for all matching labels of THIS \"default\" envoy fleet pods and will try to schedule pods onto different nodes. # Other fleets (if present) are not taken into consideration. You can specify nodeAffinity and podAffinity as well. # affinity: # podAntiAffinity: # requiredDuringSchedulingIgnoredDuringExecution: # - labelSelector: # matchExpressions: # - key: app.kubernetes.io/name # operator: In # values: # - kusk-gateway-envoy-fleet # - key: fleet # operator: In # values: # - default # topologyKey: kubernetes.io/hostname # optional, the number of Envoy Proxy pods to start size : 1 # Access logging to stdout # Optional, if this is missing no access logging to stdout will be done accesslog : # json|text format : text # Depending on format we can specify our own log template or if template is not specified - default Kusk Gateway will be used. # See https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings for the details. # Below are specified the examples of similar and minimalistic formats for both text and json format types. # Text format fields order is preserved. # The output example: # \"[2021-12-15T16:50:50.217Z]\" \"GET\" \"/\" \"200\" \"1\" text_template : | \"[%START_TIME%]\" \"%REQ(:METHOD)%\" \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" \"%RESPONSE_CODE%\" \"%DURATION%\" # Json format fields order isn't preserved # The output example: # {\"start_time\":\"2021-12-15T16:46:52.135Z\",\"path\":\"/\",\"response_code\":200,\"method\":\"GET\",\"duration\":1} json_template : start_time : \"%START_TIME%\" method : \"%REQ(:METHOD)%\" path : \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" response_code : \"%RESPONSE_CODE%\" duration : \"%DURATION%\" # TLS configuration # tls: # cipherSuites: # - ECDHE-ECDSA-AES128-SHA # - ECDHE-RSA-AES128-SHA # - AES128-GCM-SHA256 # tlsMinimumProtocolVersion: TLSv1_2 # tlsMaximumProtocolVersion: TLSv1_3 # tlsSecrets: # - secretRef: my-cert # namespace: default","title":"EnvoyFleet"},{"location":"customresources/envoyfleet/#envoy-fleet","text":"This resource defines the EnvoyFleet, which is the implementation of the gateway in Kubernetes based on Envoy Proxy. Once the resource manifest is deployed to Kubernetes, it is used by Kusk Gateway Manager to setup K8s Envoy Proxy Deployment , ConfigMap and Service . The ConfigMap config bootstraps Envoy Proxy to connect to the XDS service of the KGW Manager to retrieve the configuration. In its initial state there is a minimal configuration, you have to deploy API or StaticRoute resource to setup the routing. If the Custom Resource is uninstalled, the Manager deletes the created K8s resources. You can deploy multiple Envoy Fleets and thus have multiple Gateways available. Once the fleet is deployed, it status field shows the success of the process (Deployed, Failed), so it can be shown with kubectl describe envoyfleet command. Alpha Limitations : currently it shows only the success of K8s resources deployment, it doesn't show if the Envoy Proxy pods are alive and if the Service has the External IP Address allocated. Currently supported parameters: metadata. name and metadata. namespace are used as the EnvoyFleet ID. The Manager will supply the configuration for this specific ID - Envoy will connect to the KGW Manager with it. API/StaticRoute can be deployed to this fleet using their fleet name field. spec. image is the Envoy Proxy container image tag, usually envoyproxy/envoy-alpine. spec. service defines the configuration of the K8s Service that exposes Envoy Proxy deployment. It has similar to the K8s Service configuration but with the limited set of fields. spec.service. type - select the Service type (NodePort, ClusterIP, LoadBalancer). spec.service. ports - expose TCP ports (80, 443 or any other), routed to the ports names that Deployment exposes (http, https) - ports that Envoy Proxy listener binds to. spec.service. annotations - add annotations to the Service that will control load balancer configuration in the specific cloud providers implementations (e.g. to setup the internal Google Cloud Platform load balancer in Google Cloud Engine we annotate Service with the related annotation). spec.service. loadBalancerIP can be used to specify the pre-allocated Load Balancer IP address, so it won't be deleted in case the Service is deleted. spec.service. externalTrafficPolicy optional parameter denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. \"Local\" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. \"Cluster\" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. For the preservation of the real client ip in access logs chose \"Local\" spec. size optional parameter is the number of Envoy Proxy pods in the K8s deployment, defaults to 1 if not specified. spec. resources optional parameter configures Envoy Proxy container CPU/Memory requests and limits - read Resource Management for Pods and Containers for the details. By default we don't specify any requests or limits. spec. annotations optional parameter adds additional annotations to the Envoy Proxy pods, e.g. for the Prometheus scraping. spec. nodeSelector , spec. tolerations and spec. affinity optional parameters provide the Envoy Proxy deployment settings for the K8s Pod scheduler. Read Assigning Pods to Nodes to understand how can you bind Envoy pods to some type of nodes (e.g. non-preemtible node type pool) and how to ensure that Envoy pods are placed onto the different nodes for the High Availability. See the YAML example below too. The structure of these fields are the same as for K8s Deployment. All these options could be used simultaneously influencing each other. spec. accesslog optional parameter defines Envoy Proxy stdout HTTP requests logging. Each Envoy pod can stream access log to stdout. If not specified - no streaming. If specified, you must chose the format and optionally - text or json template to tune the output. spec.accesslog. format required parameter specifies the format of the output json (structured) or text . Note that json format doesn't preserve fields order. spec.accesslog. text_template | json_template optional parameters could be used to specify what exactly available Envoy request data to log. See Envoy's Access Logging for the details. If not specified any - use Kusk Gateway provided defaults. spec. tls optional parameter defines TLS settings for the EnvoyFleet. If not specified, the EnvoyFleet will accept only HTTP traffic. spec.tls. cipherSuites An optional field, if specified, the TLS listener will only support the specified cipher list when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3). If not specified, a default list will be used. Defaults are different for server (downstream) and client (upstream) TLS configurations. For more information see: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto spec.tls. tlsMinimumProtocolVersion An optional field specifying the minimum TLS protocol version. By default, it\u2019s TLSv1_2 for clients and TLSv1_0 for servers. spec.tls. tlsMaximumProtocolVersion An optional field specifying the maximum TLS protocol version. By default, it\u2019s TLSv1_2 for clients and TLSv1_3 for servers. spec.tls. tlsSecrets Secret name and namespace combinations for locating TLS secrets containing TLS certificates. You can specify more than one. Kusk Gateway Manager pulls the certificates from the secrets, extracts the matching hostnames from SubjectAlternativeNames (SAN) certificate field and configures Envoy to use that certificate for those hostnames. spec.tls.tlsSecrets. secretRef is the name of the Kubernetes secret containing the TLS certificate. spec.tls.tlsSecrets. namespace is the namespace where that Kubernetes secret resides. apiVersion : gateway.kusk.io/v1alpha1 kind : EnvoyFleet metadata : name : default namespace : default spec : image : \"envoyproxy/envoy-alpine:v1.20.0\" service : # NodePort, ClusterIP, LoadBalancer type : LoadBalancer # Specify annotations to modify service behaviour, e.g. for GCP to create internal load balancer: # annotations: # networking.gke.io/load-balancer-type: \"Internal\" # Specify preallocated static load balancer IP address if present #loadBalancerIP: 10.10.10.10 ports : - name : http port : 80 targetPort : http - name : https port : 443 targetPort : http # externalTrafficPolicy: Cluster|Local resources : # limits: # cpu: 1 # memory: 100M requests : cpu : 10m memory : 100M # Put any additional annotations to the Enovy pod. # Here we add the annotations for the Prometheus service discovery to scrape Envoy pods for the Prometheus metrics. # annotations: # prometheus.io/scrape: 'true' # prometheus.io/port: '19000' # prometheus.io/path: /stats/prometheus ##### Scheduling directives # Read https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/ for the details. # Optional - schedule Envoy pods to the node with the label \"disktype=ssd\". # nodeSelector: # disktype: \"ssd\" # Optional - allow to be scheduled on the \"tainted\" node. Taint with \"kubectl taint nodes node1 key1=value1:NoSchedule\". # Taints will repel the pods from the node unless the pods have the specific toleration. # The line below will allow this specific Envoy pod to be scheduled there (but scheduler decideds where to put it anyway). # tolerations: # - key: \"key1\" # operator: \"Exists\" # effect: \"NoSchedule\" # Optional - provide pods affinity and anti-affinity settings. # This is more flexible than nodeSelector scheme but they can be specified together. # For the scalability and fault tolerance we prefer to put all Envoy pods onto different nodes - in a case one node fails we survive on others. # The block below will search for all matching labels of THIS \"default\" envoy fleet pods and will try to schedule pods onto different nodes. # Other fleets (if present) are not taken into consideration. You can specify nodeAffinity and podAffinity as well. # affinity: # podAntiAffinity: # requiredDuringSchedulingIgnoredDuringExecution: # - labelSelector: # matchExpressions: # - key: app.kubernetes.io/name # operator: In # values: # - kusk-gateway-envoy-fleet # - key: fleet # operator: In # values: # - default # topologyKey: kubernetes.io/hostname # optional, the number of Envoy Proxy pods to start size : 1 # Access logging to stdout # Optional, if this is missing no access logging to stdout will be done accesslog : # json|text format : text # Depending on format we can specify our own log template or if template is not specified - default Kusk Gateway will be used. # See https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings for the details. # Below are specified the examples of similar and minimalistic formats for both text and json format types. # Text format fields order is preserved. # The output example: # \"[2021-12-15T16:50:50.217Z]\" \"GET\" \"/\" \"200\" \"1\" text_template : | \"[%START_TIME%]\" \"%REQ(:METHOD)%\" \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" \"%RESPONSE_CODE%\" \"%DURATION%\" # Json format fields order isn't preserved # The output example: # {\"start_time\":\"2021-12-15T16:46:52.135Z\",\"path\":\"/\",\"response_code\":200,\"method\":\"GET\",\"duration\":1} json_template : start_time : \"%START_TIME%\" method : \"%REQ(:METHOD)%\" path : \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" response_code : \"%RESPONSE_CODE%\" duration : \"%DURATION%\" # TLS configuration # tls: # cipherSuites: # - ECDHE-ECDSA-AES128-SHA # - ECDHE-RSA-AES128-SHA # - AES128-GCM-SHA256 # tlsMinimumProtocolVersion: TLSv1_2 # tlsMaximumProtocolVersion: TLSv1_3 # tlsSecrets: # - secretRef: my-cert # namespace: default","title":"Envoy Fleet"},{"location":"customresources/staticroute/","text":"StaticRoute This resource defines manually created routing rules. It is useful to setup the routing to a non-API application, e.g. static pages, images or route to some old (possibly external to the cluster) APIs. It is designed to overcome the shortcomings of OpenAPI based routing, one of which is the inability to configure \"catch all prefixes\" like / . Its structure is still similar to OpenAPI spec and thus is familiar for the users. The resource can be deployed additionally to the API resource or completely separately. Routing information from both resources will be merged with the priority given to the API resources. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any action with the separate resource. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will be rejected with the error. Alpha Limitations : currently resource status field is not updated by manager when the reconciliation of the configuration finishes. Configuration structure description The main elements of the configuration are in spec field. They specify how the incoming request is matched and what action to take. Below is the YAML structure of the configuration, please read on further for a full explanation. apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : staticroute-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster. fleet : name : default namespace : default hosts : [ <string> , <string> , ... ] paths : # Consists of path matchers with HTTP methods (lowercase), which in turn either: # 1. \"route\" (proxying) to the upstream host or # 2. \"redirect\" to other endpoint <path_match> : <http_method> : # \"route\" defines proxying parameters. Mutually exlusive with \"redirect\". route : # upstream is the container for the upstream host specification. upstream : # host defines the hostname to proxy to. Mutually exlusive with service. host : # DNS name to proxy to hostname : <string> # Port to proxy to port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exlusive with the \"host\". service : # service name name : <string> namespace : <string> port : 8080 # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retres define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # Optional path : # Rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regexs other than the wildcard (\"*\") are not supported right now. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser, returned with Access-Control-Max-Age. max_age : <int> # Enable establishing Websockets connections websocket : <true|false> # \"redirect\" creates HTTP redirect to other endpoint. Mutually exclusive with \"route\". redirect : # redirect to http or https scheme_redirect : <http|https> # redirect to this hostname host_redirect : <string> # redirects to different port port_redirect : <int> # redirect to different URL path. Mutually exlusive with rewrite_regex. path_redirect : \"<string>\" # redirect using the rewrite rule. Mutually exlusive with path_redirect. rewrite_regex : # regex pattern : <string> # regex parameters substitution pattern substitution : <string> # response code, by default - Permanent Redirect HTTP 308 # available HTTP codes: 301, 302, 303, 307, 308 response_code : <int> <http_method> : -- skipped -- Envoy Fleet spec. fleet optional field specifies to what Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies to. fleet. name and fleet. namespace reference the deployed EnvoyFleet Custom Resource name and namespace. You can deploy you StaticRoute configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, the autodetection will be performed to find the single deployed in the Kubernetes cluster fleet which is thus considered as the default fleet. The deployed StaticRoute custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, the spec. fleet is required to specify in the manifest. Request matching We match the incoming request by HOST header, path and HTTP method. The following fields specify matching. hosts that define the list of HOST headers this configuration applies to. This will create the Envoy's VirtualHost with the same name and domain matching. Wildcards are possible, e.g. \"*\" means \"any host\". Prefix and suffix wildcards are supported, but not both (i.e. example.*, *example.com , but not *example* ). paths is the container of URL paths + HTTP methods collection to match and handle the request during the routing decision. paths . path_match is the URL path string, starts with / (e.g. /api , /robots.txt ). The suffix hints how to match the request: paths ending with / will match everything that has that path as a prefix. E.g. /api/ matches /api/v1/id , just / is a catch all. paths without / will match that path exactly. E.g. just /resource matches exactly this resource with any possible URL query. Alpha limitations: currently regexes are currently not supported. paths . path_match . http_method adds an additional request matcher which is the lowercased HTTP method (get, post, ...). Calls to the paths with a method type that is not set here will return \"404 Not Found\". Final action on the matched request Once the request is matched, we can decide what to do with it. paths . path_match .http_method_match. route|redirect specifes the routing decision. The request can be either proxied to the upstream host (backend) or returned to the user as a redirect. Either redirect or route must be specified, but not both. Alpha Limitations: currently additional request handling (e.g. direct request response like returning 404 Not Found) is not implemented. Redirect redirect provides HTTP redirect options with the following fields. All of them are optional but once specified enable a part of redirection behaviour. redirect structure: redirect : scheme_redirect : <http|https> # redirect to http or https. host_redirect : <string> # redirect to this hostname. port_redirect : <string> # redirect to this port. path_redirect : <string> # redirect to this path, old path is removed. Mutually exclusive with rewrite_regex. rewrite_regex : # redirect to this rewritten with regex path. Mutually exclusive with path_redirect. pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. response_code : # redirect HTTP response code to return to the user. Available HTTP codes: 301, 302, 303, 307, 308 strip_query : <bool> # strip path query during redirect, default false. rewrite_regex pattern matching and substitution provides a powerful mechanism to rewrite redirect path based on incoming requests. Copy from Envoy's documentation: Indicates that during redirect, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers. Examples using Google\u2019s RE2 engine: The path pattern ^/service/([^/]+)(/.*)$ paired with a substitution string of \\2/instance/\\1 would transform /service/foo/v1/api into /v1/api/instance/foo. The pattern one paired with a substitution string of two would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz. The pattern ^(. ?)one(. )$ paired with a substitution string of \\1two\\2 would replace only the first occurrence of one, transforming path /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz. The pattern (?i)/xxx/ paired with a substitution string of /yyy/ would do a case-insensitive match and transform path /aaa/XxX/bbb to /aaa/yyy/bbb. Route route specifies how the request will be proxied to the upstream with the following fields. route structure: route : # upstream is the container for the upstream host specification. Either upstream.host or upstream.service must be specified. upstream : # host defines the hostname to proxy to. Mutually exlusive with service. host : # DNS hostname to proxy to hostname : <string> # host port port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exlusive with the \"host\". service : # K8s service name to proxy to name : <string> # service namespace namespace : <string> # service port port : <int> # Quality of Service for the request # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retres define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # What to do with the path when proxying to the upstream. # Optional path : # Rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regexs other than the wildcard (\"*\") are not supported right now. # WARNING - this is just the example, write your own CORS settings. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser in seconds, returned with Access-Control-Max-Age header max_age : <int> # Enable establishing Websockets connections websocket : <true|false> route . upstream is a required field that defines the upstream host parameters. We proxy using DNS hostname or local cluster K8s service parameters, which are further resolved to DNS hostname. Either upstream . host or upstream . service must be specified inside. route . path is an optional field that specifies what to do with the URL path when proxying to the upstream - possible values right now is to rewrite it. See the rewrite_regex section in redirect action above for the explanation. route . qos optional field is the container for request Quality of Service parameters, i.e. timeouts, failure retry policy. route . cors optional field is the container for Cross-Origin Resource Sharing headers parameters. If this field is specified, route will be augmented with CORS preflight OPTIONS HTTP method matching. This will allow Envoy to return the response to OPTIONS request with the specified here CORS headers to the user without proxying to upstream. It is advised to read CORS before trying to configure this. Note: the structure for CORS specified above is an example, i.e. one should write its own set of methods and headers. route . websocket optional boolean field defines whether to enable handling of \"Upgrade: websocket\" and related Websocket HTTP headers in the request to create a Websocket tunnel to the backend. By default false, don't handle Websockets. Example apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : sample spec : # should work with localhost, example.org, any host hosts : [ \"localhost\" , \"*\" ] paths : # Catch all prefix / / : # HTTP method GET get : route : &root_route # here we're using YAML anchors to decrease the boilerplate for all HTTP methods - the configuration is the same. upstream : host : # DNS name to proxy forward to hostname : front.somehostname.com # Port to proxy to port : 80 post : *root_route put : *root_route head : *root_route patch : *root_route # robots.txt is served by the new frontend. Here we use \"host\" to show that it can replace \"service\" safely. /robots.txt : get : route : upstream : host : hostname : front.frontapps.svc.cluster.local. port : 80 # GET to /oldstatic resource redirects to /static /oldstatic/ : get : redirect : # redirect to different path /oldstatic/blabla -> /static/blabla rewrite_regex : pattern : '/oldstatic/(.*)' substitution : '/static/\\1' response_code : 308 /static/ : get : route : upstream : service : name : \"front\" namespace : \"frontapps\" port : 80 # GET to /images/ is proxied to K8s service images in images namespace /images/ : get : route : upstream : service : name : images namespace : images port : 8080 # old API is served on other path with the rewrite of path to upstream /api/v0/ : get : route : &old_api_route upstream : service : name : api0 namespace : legacy port : 80 path : # removes /api/v0 from the path when proxying to upstream rewrite : pattern : \"^/api/v0\" substitution : \"\" # Old API is slow and unreliable qos : request_timeout : 30 idle_timeout : 60 retries : 5 cors : origins : - \"*\" methods : - GET - POST - PUT - PATCH - HEAD headers : - Content-Type - Content-Encoding credentials : false expose_headers : - X-API-VERSION max_age : 8600 websocket : true post : *old_api_route put : *old_api_route patch : *old_api_route head : *old_api_route","title":"Static Route"},{"location":"customresources/staticroute/#staticroute","text":"This resource defines manually created routing rules. It is useful to setup the routing to a non-API application, e.g. static pages, images or route to some old (possibly external to the cluster) APIs. It is designed to overcome the shortcomings of OpenAPI based routing, one of which is the inability to configure \"catch all prefixes\" like / . Its structure is still similar to OpenAPI spec and thus is familiar for the users. The resource can be deployed additionally to the API resource or completely separately. Routing information from both resources will be merged with the priority given to the API resources. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any action with the separate resource. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will be rejected with the error. Alpha Limitations : currently resource status field is not updated by manager when the reconciliation of the configuration finishes.","title":"StaticRoute"},{"location":"customresources/staticroute/#configuration-structure-description","text":"The main elements of the configuration are in spec field. They specify how the incoming request is matched and what action to take. Below is the YAML structure of the configuration, please read on further for a full explanation. apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : staticroute-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster. fleet : name : default namespace : default hosts : [ <string> , <string> , ... ] paths : # Consists of path matchers with HTTP methods (lowercase), which in turn either: # 1. \"route\" (proxying) to the upstream host or # 2. \"redirect\" to other endpoint <path_match> : <http_method> : # \"route\" defines proxying parameters. Mutually exlusive with \"redirect\". route : # upstream is the container for the upstream host specification. upstream : # host defines the hostname to proxy to. Mutually exlusive with service. host : # DNS name to proxy to hostname : <string> # Port to proxy to port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exlusive with the \"host\". service : # service name name : <string> namespace : <string> port : 8080 # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retres define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # Optional path : # Rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regexs other than the wildcard (\"*\") are not supported right now. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser, returned with Access-Control-Max-Age. max_age : <int> # Enable establishing Websockets connections websocket : <true|false> # \"redirect\" creates HTTP redirect to other endpoint. Mutually exclusive with \"route\". redirect : # redirect to http or https scheme_redirect : <http|https> # redirect to this hostname host_redirect : <string> # redirects to different port port_redirect : <int> # redirect to different URL path. Mutually exlusive with rewrite_regex. path_redirect : \"<string>\" # redirect using the rewrite rule. Mutually exlusive with path_redirect. rewrite_regex : # regex pattern : <string> # regex parameters substitution pattern substitution : <string> # response code, by default - Permanent Redirect HTTP 308 # available HTTP codes: 301, 302, 303, 307, 308 response_code : <int> <http_method> : -- skipped --","title":"Configuration structure description"},{"location":"customresources/staticroute/#envoy-fleet","text":"spec. fleet optional field specifies to what Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies to. fleet. name and fleet. namespace reference the deployed EnvoyFleet Custom Resource name and namespace. You can deploy you StaticRoute configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, the autodetection will be performed to find the single deployed in the Kubernetes cluster fleet which is thus considered as the default fleet. The deployed StaticRoute custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, the spec. fleet is required to specify in the manifest.","title":"Envoy Fleet"},{"location":"customresources/staticroute/#request-matching","text":"We match the incoming request by HOST header, path and HTTP method. The following fields specify matching. hosts that define the list of HOST headers this configuration applies to. This will create the Envoy's VirtualHost with the same name and domain matching. Wildcards are possible, e.g. \"*\" means \"any host\". Prefix and suffix wildcards are supported, but not both (i.e. example.*, *example.com , but not *example* ). paths is the container of URL paths + HTTP methods collection to match and handle the request during the routing decision. paths . path_match is the URL path string, starts with / (e.g. /api , /robots.txt ). The suffix hints how to match the request: paths ending with / will match everything that has that path as a prefix. E.g. /api/ matches /api/v1/id , just / is a catch all. paths without / will match that path exactly. E.g. just /resource matches exactly this resource with any possible URL query. Alpha limitations: currently regexes are currently not supported. paths . path_match . http_method adds an additional request matcher which is the lowercased HTTP method (get, post, ...). Calls to the paths with a method type that is not set here will return \"404 Not Found\".","title":"Request matching"},{"location":"customresources/staticroute/#final-action-on-the-matched-request","text":"Once the request is matched, we can decide what to do with it. paths . path_match .http_method_match. route|redirect specifes the routing decision. The request can be either proxied to the upstream host (backend) or returned to the user as a redirect. Either redirect or route must be specified, but not both. Alpha Limitations: currently additional request handling (e.g. direct request response like returning 404 Not Found) is not implemented.","title":"Final action on the matched request"},{"location":"customresources/staticroute/#redirect","text":"redirect provides HTTP redirect options with the following fields. All of them are optional but once specified enable a part of redirection behaviour. redirect structure: redirect : scheme_redirect : <http|https> # redirect to http or https. host_redirect : <string> # redirect to this hostname. port_redirect : <string> # redirect to this port. path_redirect : <string> # redirect to this path, old path is removed. Mutually exclusive with rewrite_regex. rewrite_regex : # redirect to this rewritten with regex path. Mutually exclusive with path_redirect. pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. response_code : # redirect HTTP response code to return to the user. Available HTTP codes: 301, 302, 303, 307, 308 strip_query : <bool> # strip path query during redirect, default false. rewrite_regex pattern matching and substitution provides a powerful mechanism to rewrite redirect path based on incoming requests. Copy from Envoy's documentation: Indicates that during redirect, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers. Examples using Google\u2019s RE2 engine: The path pattern ^/service/([^/]+)(/.*)$ paired with a substitution string of \\2/instance/\\1 would transform /service/foo/v1/api into /v1/api/instance/foo. The pattern one paired with a substitution string of two would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz. The pattern ^(. ?)one(. )$ paired with a substitution string of \\1two\\2 would replace only the first occurrence of one, transforming path /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz. The pattern (?i)/xxx/ paired with a substitution string of /yyy/ would do a case-insensitive match and transform path /aaa/XxX/bbb to /aaa/yyy/bbb.","title":"Redirect"},{"location":"customresources/staticroute/#route","text":"route specifies how the request will be proxied to the upstream with the following fields. route structure: route : # upstream is the container for the upstream host specification. Either upstream.host or upstream.service must be specified. upstream : # host defines the hostname to proxy to. Mutually exlusive with service. host : # DNS hostname to proxy to hostname : <string> # host port port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exlusive with the \"host\". service : # K8s service name to proxy to name : <string> # service namespace namespace : <string> # service port port : <int> # Quality of Service for the request # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retres define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # What to do with the path when proxying to the upstream. # Optional path : # Rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regexs other than the wildcard (\"*\") are not supported right now. # WARNING - this is just the example, write your own CORS settings. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser in seconds, returned with Access-Control-Max-Age header max_age : <int> # Enable establishing Websockets connections websocket : <true|false> route . upstream is a required field that defines the upstream host parameters. We proxy using DNS hostname or local cluster K8s service parameters, which are further resolved to DNS hostname. Either upstream . host or upstream . service must be specified inside. route . path is an optional field that specifies what to do with the URL path when proxying to the upstream - possible values right now is to rewrite it. See the rewrite_regex section in redirect action above for the explanation. route . qos optional field is the container for request Quality of Service parameters, i.e. timeouts, failure retry policy. route . cors optional field is the container for Cross-Origin Resource Sharing headers parameters. If this field is specified, route will be augmented with CORS preflight OPTIONS HTTP method matching. This will allow Envoy to return the response to OPTIONS request with the specified here CORS headers to the user without proxying to upstream. It is advised to read CORS before trying to configure this. Note: the structure for CORS specified above is an example, i.e. one should write its own set of methods and headers. route . websocket optional boolean field defines whether to enable handling of \"Upgrade: websocket\" and related Websocket HTTP headers in the request to create a Websocket tunnel to the backend. By default false, don't handle Websockets.","title":"Route"},{"location":"customresources/staticroute/#example","text":"apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : sample spec : # should work with localhost, example.org, any host hosts : [ \"localhost\" , \"*\" ] paths : # Catch all prefix / / : # HTTP method GET get : route : &root_route # here we're using YAML anchors to decrease the boilerplate for all HTTP methods - the configuration is the same. upstream : host : # DNS name to proxy forward to hostname : front.somehostname.com # Port to proxy to port : 80 post : *root_route put : *root_route head : *root_route patch : *root_route # robots.txt is served by the new frontend. Here we use \"host\" to show that it can replace \"service\" safely. /robots.txt : get : route : upstream : host : hostname : front.frontapps.svc.cluster.local. port : 80 # GET to /oldstatic resource redirects to /static /oldstatic/ : get : redirect : # redirect to different path /oldstatic/blabla -> /static/blabla rewrite_regex : pattern : '/oldstatic/(.*)' substitution : '/static/\\1' response_code : 308 /static/ : get : route : upstream : service : name : \"front\" namespace : \"frontapps\" port : 80 # GET to /images/ is proxied to K8s service images in images namespace /images/ : get : route : upstream : service : name : images namespace : images port : 8080 # old API is served on other path with the rewrite of path to upstream /api/v0/ : get : route : &old_api_route upstream : service : name : api0 namespace : legacy port : 80 path : # removes /api/v0 from the path when proxying to upstream rewrite : pattern : \"^/api/v0\" substitution : \"\" # Old API is slow and unreliable qos : request_timeout : 30 idle_timeout : 60 retries : 5 cors : origins : - \"*\" methods : - GET - POST - PUT - PATCH - HEAD headers : - Content-Type - Content-Encoding credentials : false expose_headers : - X-API-VERSION max_age : 8600 websocket : true post : *old_api_route put : *old_api_route patch : *old_api_route head : *old_api_route","title":"Example"}]}